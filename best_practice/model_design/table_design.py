"""テーブル設計

■NULLをなるべく避ける
 NULLを許容するとアプリケーション側で「NULLの場合」を扱う処理や仕様が必要になり、プログラムが煩雑になる。
 NULL可能の回避方法
 ・仕様として受け入れない
 ・デフォルト値を使う
 ・NULL不可にして空文字や0を設定

■一意制約をつける
 仕様上、想定しないデータがあればできるだけ一意制約をつける。
 「ユーザーは同じ商品に一つしか商品レビューをつけられない」という仕様であれば、「商品レビュー」tableの
 「ユーザー」と「商品」の二つのカラムに一意制約をつける。
■参照頻度が低いカラムはテーブルをわける
 テーブルのカラムが増えると参照やJOINが遅くなる問題がある。参照した時のデータ転送時に、データ量が多くなり、
 JOINする際に、必要な一時テーブルの容量が多くなるため。
 以下のようにテーブルを分離する
 ・「ユーザープロフィール」テーブル
  ・自己紹介文
  ・誕生日
  ・趣味
 ・「支払い」テーブル
  ・決済方法
  ・カードの情報
■予備カラムを用意しない
 予備カラムの問題点
  ・カラム名が意味を説明できない・・・「yobi_001はキャンペーンIDが入っている」と直感的にわからない
  ・事前に決めた型でしか扱えない・・・文字列型として数値や日付を管理する必要がでてくる。外部キーを貼れない。
  ・事前に決めたカラムの大きさで使うしかない。
 必要になった際にカラムを追加するので十分。
■bool値ではなく日時にする
 class Article(modes.Model):
     published = models.BooleanField("公開済みフラグ", default=False)
     published_at = models.DataTimeField("公開日時", default=None, null=True, blank=True)
 publishedというカラムを用意しなくても、published_atカラムを使えば、公開されたかどうかは判定できる。
 NULLの場合は「非公開」であり、データがある場合は「公開済み」と扱う。
 日時で状態が切り替わるような値や記録としてつける値の場合にはbool値でなく日時にすると良い。
 ・記事公開済みフラグ→記事公開日時
 ・メール送信済みフラグ→メール送信日時
 ・商品販売中フラグ→商品販売開始日時、終了日時
 ・課金停止フラグ→課金停止日時
 ・トークン失効フラグ→トークン失効日時
 ・支払い処理完了フラグ→支払い処理完了日時
 ・同期済みフラグ→同期日時
 以下の値はbool値が設定された日時が必要ないのでbool値が望ましい。
 ・メールマガジン購読中のような設定値
 ・アンケートやフィードバックのチェックボックスの値
■データはなるべく物理削除をする
 論理削除・・・削除フラグをカラムで持ち、削除したことにすること。
 論理削除は全てのデータ取得時に「削除済みでない」条件が必要になる。JOINをする際にも常に必要。
 外部キーで参照されているときの削除時の挙動も複雑になる。
 さらに、削除されたデータが蓄積していくのでパフォーマンスの低下していく、ユニーク制約をつけられなくなる。
 論理削除をしないのが一番。
 データを戻せるようにしたいや過去のデータを参照したいの別の解決方法
 ・別案1・・・「履歴」用のテーブルを用意して過去に削除したデータをコピーして保存する。
   ・過去のデータを活用する場合や、データを復元する動作が必要な時は有効
 ・別案2・・・ログのような情報として(DB以外に)保存しておく。
   ・データベースが肥大化しないので、参照することがほぼないのであれば有効。
   ・AWS S3などのデータストアに保存しておけば十分。
 ・別案3・・・バックアップなどを逐次とってロールバック可能にしておく。
   ・データが破壊されてしまった問題などに対処する方法として有効。

■有意コードは使わない
 有意コード・・・「FD10001」FDが商品の区分、10001が商品の番号のようなコードの桁数によって意味を持たせること。
 有意コードから値を取り出す処理が頻発して処理が汚くなる。
 問題点
 ・有意コードに含まれた意味がユーザーに意図せず伝わり問題になる。
 ・有意コードのある範囲で使っている桁数が足りなくなった場合に破綻する。
 記事コードや記事IDなどのメールでの問いわせが必要ない値はUUIDを使うと良い、
 UUID・・・ユニーク(重複しない)なIDのこと。
 有意コードが必要な場合
 ・商品コード、学生番号などがシステム運用上必要な場合がある。(商品コードがあると問い合わせの際や倉庫作業次にコミュニケーションしやすい)
 その場合もコードは他の「アカウントの登録日」や「商品の区分」から有意コードを表示できるようにする。
■カラム名の統一
 以下の場合は表記がぶれやすいので、大まかな指針を持っておく。
 ・日時(dt, datetime, at)・・・_atにするのがプログラムを書く時に理解しやすい(expires_atなど)
 ・種別(type, typ, flg, kbn)・・・Categoryなどの別tableにして外部キーにした方がいい。flag, flg, kbnは誤解しやすいので使わない。
 ・ユーザーへの外部キー(reviewed_by, review_user, reviewer)・・・単にuserとするとどういう意図でのユーザーなのかわかりにくい。担当者などはer。
                                                           記録として残す場合delete_byのように_byがわかりやすい。
 ・bool(is_published, has_published, published, published_flg)・・・is_統一すると理解しやすい。
 ・~から(since, from)・・・日時であればsinceの方が良い。主に未来の値として使う場合はfromの方が良い。
 ・~まで(until, to)・・・sinceとuntil、fromとtoの組み合わせが自然。

■DBのスキーママイグレーションとデータマイグレーションを分ける
 ・カラムの追加とデータの移行、カラムの削除を一辺に行うとデータ定義の問題でエラーとなる。
 3回のマイグレーションに分ける
 ・1回目:データの移動先フィールドを追加して、manage.pyでmakemigrations
 ・2回目:manage.py makemigrations <app> --emptyで空のmigration fileを作成し、data migrationを実装
 ・3回目:データの移動元フィールドを削除してmanage.py makemigrationsを実行
 DB操作SQL
 ・DDL(Data Definition Language)・・・Create tableやdelete、indexや制約を設定。
 ・DML(Data Manipulation Language)・・・CRUD処理。
■データマイグレーションはロールバックも実装する
 ロールバック・・・DB処理において、トランザクション処理中にエラーが発生した場合に、そのトランザクション処理を開始する前の状態までdbを戻すこと。
 Djangoなどの多くのフレームワークはスキーママイグレーションのロールバック機能を提供しているが、データマイグレーションのロールバックは提供していない。
 データもロールバックできるように実装しておけば何かあった場合の最終手段となる。
 ex)別accountディレクトリ参照

■ORMでどんなSQLが発行されているか気にする。
 dbのSQLログなどを出力すると何十行もSQLが出てくることもある。
 SQL発行ごとにDBと通信してデータをやり取りする。
 ・ORMを使ったクエリを記載したら、ORMが生成するSQLを確認する。
 ・1回のSELECTで書けるクエリが複数回に分けて実行されていたら、1つにまとめることを検討する。
 ・1つのリクエスト中に何度も同じSQLが発行されていたら、1回で済むように修正する。
 ・nplusoneというN+1問題(何行もSQLを実行する)を自動的に検出して、ログ出力や例外の送出を行うライブラリを設定し、unittestする。
■SQLから逆算してORMを組み立てる
 理想のSQLを書いてからそのSQLをORMで発行するように実装する。
"""