# ロギング

■トラブル解決に役立つログを出力しよう
- 開発者にとってもっとも分かりやすいエラー出力はトレースバック。
- 危険度に応じたログレベル設定とログ監視による自動通知を組み合わせることで、自動検知できるようにする。
- 本番環境では、INFOまで、検証環境ではDEBUGまでというように環境によって出力するログレベルを指定する。

■ログメッセージをフォーマットしてロガーに渡さない

```python
logger.info(f"Number of Items: {len(items)}")
```
- formatはロギングの時はしてはいけない。ログを運用する際にメッセージを集約することがあるため。  
&nbsp;例えばSentryはログのメッセージ単位で集約して、同一の原因のログを集約、特定する。  
&nbsp;ここで事前にフォーマットをしてしまうと全く別々のログメッセージと判断されてしまう。  
&nbsp;pythonのロギングは内部的にメッセージと引数を分けて管理しているので、分けたままログに残すべき。  
&nbsp;単にファイルに出力したり画面に表示するだけなら事前にフォーマットしても問題ないが、後でログを集約する  
&nbsp;仕組みを導入したら全て修正する必要が出てくる.

```python
logger.info("Number of Items: %s", len(items))
```
- 「flake8-logging-format」というflake8のプラグインがある、このプラグインをflake8で使うと  
&nbsp;ログメッセージをフォーマットしている場合に検出してくれる。

■個別の名前でロガーを作らない。

- ロガーはモジュール名__name__を使って取得する。
- pythonでは「.」区切りでloggerが適用される。ロガーの名前がproduct.views.apiのとき、  
&nbsp;product.views.api, product.views, productと順にログの設定を探して、設定があれば使われる。
- pythonでは__name__で現在のモジュールを取得できるので、まとめて設定することができる。
```python
import logging

logger = logging.getLogger(__name__)

logging.dictConfig({
    "loggers": {
        "product.views": {},
        "product.management.commands": {},
    }
})
```

■info, errorだけでなくログレベルを使い分ける。

- ログレベルの設定方法
    - debug: ローカル環境で開発する時だけ使う情報
    - info: プログラムの状況や変数の内容、処理するデータ数など、後から挙動を把握しやすくするために残す情報
    - warning: プログラムの処理は続いているが、何かしら良くないデータや通知すべきことについての情報
    - error: プログラム上の処理が中断したり、停止した場合の情報
    - critical: システム全体や連携システムに影響する重大な問題が発生した場合の情報

ワーニングレベル以上は、運営側の「何かしらのアクション」が必要になる。エラーレベル以上の場合は急ぎの対応が必要。
- 環境ごとの設定方法
    - ローカル環境：debugログ以上をコンソール出力する。
    - 動作確認用サーバー：infoログ以上をファイル出力する
    - 本番サーバー：
        - infoログをファイル出力して、ファイルストレージなどに転送、圧縮して保存する。
        - warningログをSentryに集約する。
        - errorログ以上をSentryに集約し、SentryからSlack(チャット)に通知する。

ワーニング以上では、アクションが必要になるので以下3点のポイントを押さえておく。
- 通知によってすぐに気づけるようにする。
- エラー発生時の対応方法をドキュメントにまとめておく。
- エラーを定期的に確認、対応する業務フローを決めておく。

■ログにはprintでなくloggerを使う
- printでは環境による切り替えができないため、loggingを使う。

■ログには5W1Hを書く

ログは運用時に、なるべく早く問題の原因を特定し、リカバリーする際に必要となる。  
ログファイルを後でgrepした時に目的のログだけを取り出せるように意識する。  
重要なバッチ処理であれば、処理ごとにトランザクションIDを発行してログの先頭につけると、  
あとで追跡調査がしやすくなる。  

- What: どの処理を、何を対象に行なっているか。
    - 対象データはどれなのか
    - 何行目を処理しているのか、何行目で問題があったか
- Who: どのユーザーが対象なのか。
- When: いつのログなのか。
    - ロガーの設定で日時を出力するように設定しておく
- Where: どこまで処理が進んだのか、どこで発生しているログなのか
    - ロガー名をpythonモジュールのパスにして、どのモジュールで発生したかログがわかるようにする
    - エラーログの文字列でどの処理かをわかるようにする
- Why: なぜ発生したログなのか。
    - エラーログを残す時に、エラーのメッセージやexc_infoを残すようにする
    - exc_info=Trueを指定するとエラー時のトレースバックがログに出力される
- How much: どれくらいのデータ量なのか
    - 店舗ごとの売上件数が何件なのか

■ログファイルを管理する

webアプリケーションをサーバーまで含めて管理した場合、パッと思いつくだけでも以下のようなログファイルがある。
- NginxやApacheなどのwebサーバーのアクセスログ、エラーログ
- webアプリケーションのログファイル、エラーログ
- systemdなどで稼働している各種サービス、ミドルウェアのログ

ログローテーション・・・ログファイルをサーバーに蓄える場合、ログファイルの容量が大きくなるので、サーバーのディスク容量がいっぱいになる前に、  
古いログデータは削除したり、ログを一定期間でまとめて圧縮すること。

■Sentryでエラーログを通知/監視する

- Sentry: エラートラッキングサービス。連続する同じエラーをまとめて1回だけ通知してくれる。また、ログだけでなく、  
&nbsp;&nbsp;エラー発生回数や頻度、ユーザーのブラウザ情報、ブラウザからPOSTされたデータ、発行されたSQLなど、多くの情報が通知される。  
&nbsp;&nbsp;エラーレベル別に設定を変更し、Warningレベル以上はGithubのIssueを自動作成したり、Errorレベル以上はSlackに通知するなど。  
