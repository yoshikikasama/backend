# ロギング

■ トラブル解決に役立つログを出力しよう

- 開発者にとってもっとも分かりやすいエラー出力はトレースバック。
- 危険度に応じたログレベル設定とログ監視による自動通知を組み合わせることで、自動検知できるようにする。
- 本番環境では、INFO まで、検証環境では DEBUG までというように環境によって出力するログレベルを指定する。

■ ログメッセージをフォーマットしてロガーに渡さない

```python
logger.info(f"Number of Items: {len(items)}")
```

- format はロギングの時はしてはいけない。ログを運用する際にメッセージを集約することがあるため。
  - 例えば Sentry はログのメッセージ単位で集約して、同一の原因のログを集約、特定する。
  - ここで事前にフォーマットをしてしまうと全く別々のログメッセージと判断されてしまう。
  - python のロギングは内部的にメッセージと引数を分けて管理しているので、分けたままログに残すべき。
  - 単にファイルに出力したり画面に表示するだけなら事前にフォーマットしても問題ないが、後でログを集約する
  - 仕組みを導入したら全て修正する必要が出てくる.

```python
logger.info("Number of Items: %s"%len(items))
```

- 「flake8-logging-format」という flake8 のプラグインがある、このプラグインを flake8 で使うと  
  &nbsp;ログメッセージをフォーマットしている場合に検出してくれる。

■ 個別の名前でロガーを作らない。

- ロガーはモジュール名**name**を使って取得する。
- python では「.」区切りで logger が適用される。ロガーの名前が product.views.api のとき、  
  &nbsp;product.views.api, product.views, product と順にログの設定を探して、設定があれば使われる。
- python では**name**で現在のモジュールを取得できるので、まとめて設定することができる。
- https://docs.python.org/ja/3/howto/logging.html

```python
import logging

logger = logging.getLogger(__name__)

logging.dictConfig({
    "loggers": {
        "product.views": {},
        "product.management.commands": {},
    }
})
```

■info, error だけでなくログレベルを使い分ける。

- ログレベルの設定方法
  - debug: ローカル環境で開発する時だけ使う情報
  - info: プログラムの状況や変数の内容、処理するデータ数など、後から挙動を把握しやすくするために残す情報
  - warning: プログラムの処理は続いているが、何かしら良くないデータや通知すべきことについての情報
  - error: プログラム上の処理が中断したり、停止した場合の情報
  - critical: システム全体や連携システムに影響する重大な問題が発生した場合の情報

ワーニングレベル以上は、運営側の「何かしらのアクション」が必要になる。エラーレベル以上の場合は急ぎの対応が必要。

- 環境ごとの設定方法
  - ローカル環境：debug ログ以上をコンソール出力する。
  - 動作確認用サーバー：info ログ以上をファイル出力する
  - 本番サーバー：
    - info ログをファイル出力して、ファイルストレージなどに転送、圧縮して保存する。
    - warning ログを Sentry に集約する。
    - error ログ以上を Sentry に集約し、Sentry から Slack(チャット)に通知する。

ワーニング以上では、アクションが必要になるので以下 3 点のポイントを押さえておく。

- 通知によってすぐに気づけるようにする。
- エラー発生時の対応方法をドキュメントにまとめておく。
- エラーを定期的に確認、対応する業務フローを決めておく。

■ ログには print でなく logger を使う

- print では環境による切り替えができないため、logging を使う。

■ ログには 5W1H を書く

ログは運用時に、なるべく早く問題の原因を特定し、リカバリーする際に必要となる。  
ログファイルを後で grep した時に目的のログだけを取り出せるように意識する。  
重要なバッチ処理であれば、処理ごとにトランザクション ID を発行してログの先頭につけると、  
あとで追跡調査がしやすくなる。

- What: どの処理を、何を対象に行なっているか。
  - 対象データはどれなのか
  - 何行目を処理しているのか、何行目で問題があったか
- Who: どのユーザーが対象なのか。
- When: いつのログなのか。
  - ロガーの設定で日時を出力するように設定しておく
- Where: どこまで処理が進んだのか、どこで発生しているログなのか
  - ロガー名を python モジュールのパスにして、どのモジュールで発生したかログがわかるようにする
  - エラーログの文字列でどの処理かをわかるようにする
- Why: なぜ発生したログなのか。
  - エラーログを残す時に、エラーのメッセージや exc_info を残すようにする
  - exc_info=True を指定するとエラー時のトレースバックがログに出力される
- How much: どれくらいのデータ量なのか

  - 店舗ごとの売上件数が何件なのか

- ログファイルを後で grep したときに抽出できるように処理ごとに transaction id などを発行してログの先頭につける。

■ ログファイルを管理する

web アプリケーションをサーバーまで含めて管理した場合、パッと思いつくだけでも以下のようなログファイルがある。

- Nginx や Apache などの web サーバーのアクセスログ、エラーログ
- web アプリケーションのログファイル、エラーログ
- systemd などで稼働している各種サービス、ミドルウェアのログ

ログローテーション・・・ログファイルをサーバーに蓄える場合、ログファイルの容量が大きくなるので、サーバーのディスク容量がいっぱいになる前に、  
古いログデータは削除したり、ログを一定期間でまとめて圧縮すること。

■Sentry でエラーログを通知/監視する

- Sentry: エラートラッキングサービス。連続する同じエラーをまとめて 1 回だけ通知してくれる。また、ログだけでなく、  
  &nbsp;&nbsp;エラー発生回数や頻度、ユーザーのブラウザ情報、ブラウザから POST されたデータ、発行された SQL など、多くの情報が通知される。  
  &nbsp;&nbsp;エラーレベル別に設定を変更し、Warning レベル以上は Github の Issue を自動作成したり、Error レベル以上は Slack に通知するなど。
