# テーブル設計

■NULL をなるべく避ける

- NULL を許容するとアプリケーション側で「NULL の場合」を扱う処理や仕様が必要になり、プログラムが煩雑になる。
- NULL 可能の回避方法
  - 仕様として受け入れない
  - デフォルト値を使う
  - NULL 不可にして空文字や 0 を設定

■ 一意制約をつける

- 仕様上、想定しないデータがあればできるだけ一意制約をつける。
- 「ユーザーは同じ商品に一つしか商品レビューをつけられない」という仕様であれば、「商品レビュー」table の  
  &nbsp;「ユーザー」と「商品」の二つのカラムに一意制約をつける。

■ 参照頻度が低いカラムはテーブルをわける

- テーブルのカラムが増えると参照や JOIN が遅くなる問題がある。参照した時のデータ転送時に、データ量が多くなり、  
  &nbsp;JOIN する際に、必要な一時テーブルの容量が多くなるため。
- 以下のようにテーブルを分離する
  - 「ユーザープロフィール」テーブル
    - 自己紹介文
    - 誕生日
    - 趣味
  - 「支払い」テーブル
    - 決済方法
    - カードの情報

■ 予備カラムを用意しない

- 予備カラムの問題点
  - カラム名が意味を説明できない・・・「yobi_001 はキャンペーン ID が入っている」と直感的にわからない
  - 事前に決めた型でしか扱えない・・・文字列型として数値や日付を管理する必要がでてくる。外部キーを貼れない。
  - 事前に決めたカラムの大きさで使うしかない。
- 必要になった際にカラムを追加するので十分。

■bool 値ではなく日時にする

```python:
class Article(modes.Model):
  published = models.BooleanField("公開済みフラグ", default=False)
  published_at = models.DataTimeField("公開日時", default=None, null=True, blank=True)
```

- published というカラムを用意しなくても、published_at カラムを使えば、公開されたかどうかは判定できる。
- NULL の場合は「非公開」であり、データがある場合は「公開済み」と扱う。
- 日時で状態が切り替わるような値や記録としてつける値の場合には bool 値でなく日時にすると良い。
  - 記事公開済みフラグ → 記事公開日時
  - メール送信済みフラグ → メール送信日時
  - 商品販売中フラグ → 商品販売開始日時、終了日時
  - 課金停止フラグ → 課金停止日時
  - トークン失効フラグ → トークン失効日時
  - 支払い処理完了フラグ → 支払い処理完了日時
  - 同期済みフラグ → 同期日時
- 以下の値は bool 値が設定された日時が必要ないので bool 値が望ましい。
  - メールマガジン購読中のような設定値
  - アンケートやフィードバックのチェックボックスの値

■ データはなるべく物理削除をする

- 論理削除・・・削除フラグをカラムで持ち、削除したことにすること。
- 論理削除は全てのデータ取得時に「削除済みでない」条件が必要になる。JOIN をする際にも常に必要。  
  &nbsp;外部キーで参照されているときの削除時の挙動も複雑になる。  
  &nbsp;さらに、削除されたデータが蓄積していくのでパフォーマンスの低下していく、ユニーク制約をつけられなくなる。  
  &nbsp;論理削除をしないのが一番。
- データを戻せるようにしたいや過去のデータを参照したいの別の解決方法
  - 別案 1・・・「履歴」用のテーブルを用意して過去に削除したデータをコピーして保存する。
    - 過去のデータを活用する場合や、データを復元する動作が必要な時は有効
  - 別案 2・・・ログのような情報として(DB 以外に)保存しておく。
    - データベースが肥大化しないので、参照することがほぼないのであれば有効。
    - AWS S3 などのデータストアに保存しておけば十分。
  - 別案 3・・・バックアップなどを逐次とってロールバック可能にしておく。
    - データが破壊されてしまった問題などに対処する方法として有効。

■ 有意コードは使わない

- 有意コード・・・「FD10001」FD が商品の区分、10001 が商品の番号のようなコードの桁数によって意味を持たせること。  
  &emsp; &emsp; 有意コードから値を取り出す処理が頻発して処理が汚くなる。
- 問題点
  - 有意コードに含まれた意味がユーザーに意図せず伝わり問題になる。
  - 有意コードのある範囲で使っている桁数が足りなくなった場合に破綻する。
- 記事コードや記事 ID などのメールでの問いわせが必要ない値は UUID を使うと良い、
- UUID・・・ユニーク(重複しない)な ID のこと。
- 有意コードが必要な場合
  - 商品コード、学生番号などがシステム運用上必要な場合がある。(商品コードがあると問い合わせの際や倉庫作業時にコミュニケーションしやすい)  
    &nbsp;&nbsp;その場合もコードは他の「アカウントの登録日」や「商品の区分」から有意コードを表示できるようにする。

■ カラム名の統一

- 以下の場合は表記がぶれやすいので、大まかな指針を持っておく。
  - 日時(dt, datetime, at)・・・\_at にするのがプログラムを書く時に理解しやすい(expires_at など)
  - 種別(type, typ, flg, kbn)・・・Category などの別 table にして外部キーにした方がいい。flag, flg, kbn は誤解しやすいので使わない。
  - ユーザーへの外部キー(reviewed_by, review_user, reviewer)・・・単に user とするとどういう意図でのユーザーなのかわかりにくい。担当者などは er。記録として残す場合 delete_by のように\_by がわかりやすい。
  - bool(is*published, has_published, published, published_flg)・・・is*統一すると理解しやすい。
  - ~から(since, from)・・・日時であれば since の方が良い。主に未来の値として使う場合は from の方が良い。
  - ~まで(until, to)・・・since と until、from と to の組み合わせが自然。

■DB のスキーママイグレーションとデータマイグレーションを分ける

- カラムの追加とデータの移行、カラムの削除を一辺に行うとデータ定義の問題でエラーとなる。
- 3 回のマイグレーションに分ける
  - 1 回目:データの移動先フィールドを追加して、manage.py で makemigrations
  - 2 回目:manage.py makemigrations <app> --empty で空の migration file を作成し、data migration を実装
  - 3 回目:データの移動元フィールドを削除して manage.py makemigrations を実行
- DB 操作 SQL
  - DDL(Data Definition Language)・・・Create table や delete、index や制約を設定。
  - DML(Data Manipulation Language)・・・CRUD 処理。

■ データマイグレーションはロールバックも実装する(model_design/account/migrations/0003_auto_2-191126_1642.py)

- ロールバック・・・DB 処理において、トランザクション処理中にエラーが発生した場合に、そのトランザクション処理を開始する前の状態まで db を戻すこと。
- Django などの多くのフレームワークはスキーママイグレーションのロールバック機能を提供しているが、データマイグレーションのロールバックは提供していない。
- データもロールバックできるように実装しておけば何かあった場合の最終手段となる。  
  &nbsp;ex)別 account ディレクトリ参照

■ORM でどんな SQL が発行されているか気にする。

- db の SQL ログなどを出力すると何十行も SQL が出てくることもある。
- SQL 発行ごとに DB と通信してデータをやり取りする。
  - ORM を使ったクエリを記載したら、ORM が生成する SQL を確認する。
  - 1 回の SELECT で書けるクエリが複数回に分けて実行されていたら、1 つにまとめることを検討する。
  - 1 つのリクエスト中に何度も同じ SQL が発行されていたら、1 回で済むように修正する。
  - django では select_related や prefetch_related を使用する。
  - nplusone という N+1 問題(何行も SQL を実行する)を自動的に検出して、ログ出力や例外の送出を行うライブラリを設定し、unittest する。

■SQL から逆算して ORM を組み立てる

- 理想の SQL を書いてからその SQL を ORM で発行するように実装する。
