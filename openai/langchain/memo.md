# LangChain について

- LangChain: 「ChatGPT などの言語系モデルの機能拡張を効率的に実装するためのライブラリ」です。

- Models: OpenAI をはじめとした様々な言語モデル・チャットモデル・エンべディングモデルを切り替えたり、組み合わせたりすることができる機能
- Prompt: 「プロンプトの管理・最適化・シリアル化などをすることができる機能」
  - プロンプトのテンプレート化」や「few-shot learning」などの機能をパッケージ化
- Indexes: 「PDF や CSV などの外部データを用いて回答を生成する機能」です。
- Chain: 「複数のプロンプト入力を実行する機能」です。
- Agents: 「言語モデルに渡されたツールを用いて、モデル自体が次にどのようなアクションを取るかを決定し、実行し、観測し、完了するまで繰り返す機能」です。
- Memory: 「Chains や Agents の内部における状態保持をする機能」です。


## Models

- 現在のLangChainは、「LLMs・Chat Models・Text Embedding Models」に対応しています。

- LLMs: 「Large Language Modelsの略で、大規模言語モデル（LLMs）のこと」
- Text Embedding Modelsとは「自然言語の文章をなんらかの空間におけるベクトルにするモデル」です。
  - 例えば、「フリーランス」という単語と関連度の高いキーワードを生成したいとします。この時、『「エンジニア」と「猫」のどちらの単語がより関連度が高いですか？』という問題があったとします。
  - 私たちは直感的に、エンジニアの方が関連度が高いと思い浮かべることができますが、機械の場合、自然言語の状態だと関連度を計算することは難しいです。
  - そこで、「エンべディング」を行い、自然言語をベクトル化（すなわち数値化）することで、単語と単語の間の距離から関連度を求めることができます。
  - このように、言語同士の関連性などを計算したい時などに、エンべディングモデルが必要になってきます。

- Chat Modelsでは、Langchainの中に入っている「ChatOpenAI」を呼び戻します。

## Prompt

- Prompt Template: 「プロンプトをテンプレート化し、プログラミングによりプロンプトを生成するための機能」です。
  - 単純に文章内の特定の単語を変数化して、虫食いにしたテンプレートだけでなく、教師データを入力するためのテンプレートも作成可能です。
  - 例えば、フルーツの名前から色を出力する指示をするときに、「りんご：赤、キウイ：緑、ぶどう：紫」というように少数の教師データを入れるfew-shot learningと言われる手法を使うときに便利です。
- Example Selectors: 大量の教師データからプロンプトに入力するデータを選択するための機能
  - 例えば、100件の教師データがあった場合、その中から30個をランダム抽出するような機能を作るときに便利です。
- Output Parsers: 出力のデータ形式を指定するための機能
  - 例えば、出力をカンマ区切りの形式や指定したクラスの形式で出力できます。
  - また、もしも指定したフォーマットにならなかった時に、そのフォーマットになるまで修正を繰り返してくれる機能などもあります。

## indexes

- Indexes: PDFやCSVなどの外部データを用いて回答を生成する機能です。

- Document Loaders: PDFやCSVなどのデータを読み込むための機能
- Text Splitters: 文章データを分割するための機能
  - また、トークン数で分割することもでき、プロンプトのトークン数を制御する際にも便利です。
- Vectorstores: ベクトル化されたデータを管理するための機能。この機能を用いることで、自然言語をベクトル化（すなわちエンべディング）したデータを管理できます。
  - 現在は「Chroma」というベクトル型ストアがデフォルトのデータベースとして採用されていますが、それ以外にも、「FAISS・Redis・ElasticSearch」なども使うことができます。
- ベクトル化:
  - 例えば、以下の文章を考えます。
    - 「ディープラーニングは、人工知能の一分野であり、画像認識や自然言語処理などに応用されます。」
  - この文章から、ストップワードを取り除いて、単語を正規化した結果、以下のようになります。
    - ディープラーニング 人工知能 分野 画像認識 自然言語処理 応用
  - これらの単語をベクトル化する際に、TF-IDF（Term Frequency-Inverse Document Frequency）という手法を用いることが一般的です。TF-IDFは、ある単語が特定の文章内でどの程度頻出しているかを表す「Term Frequency」と、その単語が全ての文章でどの程度頻出しているかを表す「Inverse Document Frequency」を掛け合わせた値です。以下に、各単語のTF-IDF値を示します。
    - ディープラーニング 0.14
    - 人工知能 0.14
    - 分野 0.0
    - 画像認識 0.29
    - 自然言語処理 0.29
    - 応用 0.14
  - これらの値を要素とするベクトルを生成すると、以下のようになります。
    - [0.14, 0.14, 0.0, 0.29, 0.29, 0.14]
- Retrievers: ドキュメント検索をするための機能。例えば、長い文章を複数のドキュメントという塊に分割し、その中からプロンプトの関連のある情報が入ったドキュメントを検索することができます。

## Chains

- Chains: 「複数のプロンプト入力を実行する機能」です。
  - この機能は、複雑な問題を解きたいときに、実はものすごくインパクトを生み出します！
  - 例えば、複雑な問題を解きたい場合、中間的な回答を一度出力することで、より正確な回答を得たいときなどに有用です。ちなみに、このように中間的な推論ステップを踏むことで性能向上を図る手法を、「CoTプロンプティング」と呼びます。

- Simple Chain: 複数のChainを繋げていく上で最小単位となるChain
- Sequential Chain: 複数のChainを繋げたChain
- Custom Chain: 自由にChainを繋ぎ合わせることができるオリジナルのChain  
  - 複数のChainが入力された時に、各Chainの出力をどのように他のChainに渡していくかを設定したりできます。

## Agents

- Agents言語モデルに渡されたツールを用いて、モデル自体が次にどのようなアクションを取るかを決定、実行、観測し、完了するまで繰り返す機能です。
  - イメージを伝えるために、1つの例を紹介します。
  - 例えば「Google検索をするツール」と「Pythonのコードを実行するツール」を渡すことで、最新の情報に関する質問が来たときには検索をし、Pythonの実行結果などを求められたときには実際にインタープリタで実行したりすることができます。

- Tools: Agentというロボットが外界とやり取りをするための機能
- Agents: プロンプトの内容に応じてツールを使い分け、自動で解法を生成してくれるロボットの機能
  - zero-shot-react-description: ツールの説明文章などから、どのツールを用いるかを決めるAgent
  - react-docstore: 文書を扱うことに特化したAgent
  - self-ask-with-search: 質問に対する答えを事実に基づいて調べてくれるAgent
  - conversational-react-description: 会話を扱うことに特化したAgent
- Toolkits: 特定のユースケースに応じて、ツールを初期搭載したAgentの機能
- Agent Executor: Agentの行動を実行するための機能
  
## Memory

- Memory: ChainsやAgentsの内部における状態保持をする機能

- Chat Message History: Chatの履歴データを管理するための機能
  - より具体的に説明すると、HumanMessageやAIMessageなどが格納された配列の操作を簡単にする便利ツールです。
  - 例えば、ChatMessageHistoryクラスのインスタンスに対して、HumanMessageを追加したいときに、add_user_messageというメソッドを使って、簡単に追加できます。
- Simple Memory: Chain上で最初に設定できる共有メモリの機能
  - 時間や場所などの前提情報を格納することができ、SequentialChainのインスタンスを作成するときにSimple Memoryを紐づけると、そのSequentialChainの中のすべてのChainにおいて、前提情報となる変数を用いることができます。
- Buffer Memory: ChainsやAgents間で履歴データを共有するためのメモリ機能
  - 少し複雑ですが、Buffer Memoryにおけるメモリ空間の履歴データは、ChatMessageHistoryクラスを基本としています。
  - このメモリ空間上のデ  ータを、ChainsやAgents間でやり取りできるようにしたChatMessageHistoryを拡張したクラスと考えることができます。
  - Buffer Memoryを使用することで、チャットを実行するたびに履歴を管理する手間が省かれ、履歴データが自動的に更新されます。